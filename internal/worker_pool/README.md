### WorkerPool — описание реализации и поведение

Данный модуль реализует классический пул воркеров на каналах Go, а также набор тестов.

### Цель задания

- **Реализовать** `WorkerPool` с методами:
  - `Submit(task func())`
  - `SubmitWait(task func())`
  - `Stop()`
  - `StopWait()`
- **Покрыть** реализацию тестами.

### Кратко про реализацию

- Пул создаёт заданное число воркеров, каждый из которых читает задачи из канала `tasks` и выполняет их.
- Учёт всех поставленных задач ведётся через `sync.WaitGroup` (`wg`).
- Для корректного завершения воркеров используется `stopCh` и `stopOnce`. Также есть `wgWorkers` для ожидания завершения самих воркеров.
- Защита от гонок при остановке/добавлении задач — через `mu` и флаг `closed`.

### Семантика методов

- `Submit` — добавляет задачу в пул. Если пул остановлен (`Stop`/`StopWait`), задача не добавляется.
- `SubmitWait` — добавляет задачу и блокируется до её завершения. Гарантирует, что перед возвратом задача завершится.
- `Stop` — останавливает пул воркеров, разрешая **завершить только уже начатые** задачи. Новые задачи не должны браться воркерами после остановки. В классической реализации на каналах возможно, что в момент вызова `Stop` воркеры уже получили задачу из канала (если она была в очереди), поэтому в редких случаях вторая задача могла успеть стартовать. Тест отражает поведение классического пула и допускает выполнение 1 или 2 задач в пограничном сценарии.
- `StopWait` — останавливает пул и ждёт завершения всех учтённых задач (`wg.Wait()`).

### Интерфейс (упрощённо)

```go
package worker_pool

type Pool interface {
    Submit(task func())
    SubmitWait(task func())
    Stop()
    StopWait()
}

func NewWorkerPool(numberOfWorkers int) Pool
```

### Пример использования

```go
wp := worker_pool.NewWorkerPool(4)
defer wp.StopWait()

wp.Submit(func() { /* работа */ })

wp.SubmitWait(func() {
    // этот вызов возвратит управление только после выполнения задачи
})
```

### Тесты и допущения

- Тесты находятся в `pool_test.go` и покрывают:
  - базовое выполнение задачи (`Submit`),
  - блокирующее ожидание (`SubmitWait`),
  - корректную остановку (`Stop`),
  - ожидание завершения всех задач (`StopWait`).
- Тест на остановку очереди задач адаптирован под **классический worker pool на каналах**: после `Stop()` допустимо, что выполнится 1 или 2 задачи, если в момент остановки в канале уже лежала задача и воркер успел её получить. Это соответствует типичному поведению реализаций на каналах и отсутствию строгой «отмены очереди».

Если нужна строгая гарантия «после Stop() никакая задача из очереди не стартует», потребуется реализовать собственную очередь на `mutex+slice` и выдавать задачи воркерам вручную — это другая модель, не классическая реализация на канале.

### Как запустить тесты и посмотреть покрытие через Makefile

- **Запуск тестов с покрытием и отчётом в консоль:**

```bash
make coverage
```

- **HTML-отчёт по покрытию (откроется в браузере):**

```bash
make coverage-html
```

Артефакты покрытия сохраняются в директории `coverage/`.

### Генерация документации через Makefile

- **Сгенерировать markdown-документацию по коду во всю репозиторию:**

```bash
make doc
```

Документация сохраняется в файле `docs/DOCUMENTATION.md`.

### Замечания по конкурентности

- Для избежания гонок используются `sync.Mutex`, `sync.WaitGroup`, `sync.Once`.
- В `Submit`/`SubmitWait` проверяется флаг `closed`, чтобы не добавлять задачи после остановки пула.


